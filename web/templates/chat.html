<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat App</title>
    <link rel="stylesheet" href="/static/css/main.css">
</head>

<body>
    <div class="chat-container">
        <div class="chat-sidebar">
            <div class="user-profile">
                <div class="avatar">
                    <span id="userInitial"></span>
                </div>
                <div class="user-info">
                    <h3 id="username">Loading...</h3>
                    <div class="status online">Online</div>
                </div>
            </div>

            <div class="sidebar-tabs">
                <button class="tab-btn active" data-tab="conversations">Conversations</button>
                <button class="tab-btn" data-tab="users">Users</button>
            </div>

            <div class="tab-content active" id="conversations-tab">
                <div class="search-bar">
                    <input type="text" placeholder="Search conversations..." id="conversation-search">
                </div>
                <div class="conversation-list" id="conversation-list">
                    <!-- Conversations will be populated here -->
                    <div class="empty-state">
                        <p>No conversations yet.</p>
                        <p>Start a chat with someone from the Users tab.</p>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="users-tab">
                <div class="search-bar">
                    <input type="text" placeholder="Search users..." id="users-search">
                </div>
                <div class="user-list" id="user-list">
                    <!-- Users will be populated here -->
                    <div class="loading">Loading users...</div>
                </div>
                <div class="pagination">
                    <button id="load-more-users" class="btn btn-outline btn-sm">Load More</button>
                </div>
            </div>

            <div class="user-actions">
                <button id="logoutBtn" class="btn btn-outline">Logout</button>
            </div>
        </div>

        <div class="chat-main">
            <div class="chat-header" id="chat-header">
                <h2>Welcome to Chat App</h2>
                <p>Select a user or conversation to start chatting.</p>
            </div>

            <div class="messages" id="messageArea">
                <div class="welcome-message">
                    <h3>Start a conversation</h3>
                    <p>Select a user from the list to start chatting.</p>
                </div>
            </div>

            <div class="message-input-container" id="message-input-container" style="display: none;">
                <div class="typing-indicator" id="typing-indicator" style="display: none;">
                    <span id="typing-username"></span> is typing...
                </div>
                <div class="message-input">
                    <textarea id="message-input" placeholder="Type a message..."></textarea>
                    <button id="send-button" class="btn btn-primary">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Global variables
            let currentConversationId = null;
            let currentRecipientId = null;
            let currentRecipientUsername = null;
            let socket = null;
            let typingTimeout = null;
            let userPage = 1;
            let userSearchTerm = '';
            let usersHasMore = true;
            let typingIndicatorVisible = false;

            // Check if user is authenticated
            const accessToken = localStorage.getItem('access_token');
            const username = localStorage.getItem('username');
            const userId = localStorage.getItem('user_id');
            const expiresAt = localStorage.getItem('expires_at');

            if (!accessToken || !username || !userId) {
                // Not authenticated, redirect to login
                window.location.href = '/login';
                return;
            }

            // Check if token is expired
            if (new Date(expiresAt) < new Date()) {
                // Token expired, try to refresh
                refreshToken();
            }

            // Update UI with user info
            document.getElementById('username').textContent = username;
            document.getElementById('userInitial').textContent = username.charAt(0).toUpperCase();

            // Setup tabs
            setupTabs();

            // Setup logout button
            document.getElementById('logoutBtn').addEventListener('click', logout);

            // Load conversations
            loadConversations();

            // Load users
            loadUsers();

            // Initialize WebSocket connection
            initializeWebSocket();

            // Setup search functionality
            document.getElementById('users-search').addEventListener('input', function () {
                userSearchTerm = this.value;
                userPage = 1;
                loadUsers(true); // true to reset users
            });

            // Setup load more button
            document.getElementById('load-more-users').addEventListener('click', function () {
                userPage++;
                loadUsers(false); // false to append users
            });

            // Setup send message functionality
            document.getElementById('send-button').addEventListener('click', sendMessage);
            document.getElementById('message-input').addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                } else {
                    sendTypingIndicator('typing');
                }
            });

            // Functions
            function setupTabs() {
                const tabButtons = document.querySelectorAll('.tab-btn');
                const tabContents = document.querySelectorAll('.tab-content');

                tabButtons.forEach(button => {
                    button.addEventListener('click', function () {
                        const tabName = this.dataset.tab;

                        // Remove active class from all buttons and tabs
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        tabContents.forEach(content => content.classList.remove('active'));

                        // Add active class to clicked button and corresponding tab
                        this.classList.add('active');
                        document.getElementById(`${tabName}-tab`).classList.add('active');
                    });
                });
            }

            async function loadUsers(reset = true) {
                try {
                    const searchParam = userSearchTerm ? `&search=${encodeURIComponent(userSearchTerm)}` : '';
                    const response = await fetch(`/users?page=${userPage}&limit=20${searchParam}`, {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Failed to load users');
                    }

                    const data = await response.json();
                    const userList = document.getElementById('user-list');

                    if (reset) {
                        userList.innerHTML = '';
                    }

                    if (data.users.length === 0) {
                        if (reset) {
                            userList.innerHTML = '<div class="empty-state"><p>No users found.</p></div>';
                        }
                        usersHasMore = false;
                    } else {
                        // Append users to list
                        data.users.forEach(user => {
                            // Skip current user
                            if (user.user_id === userId) return;

                            const userItem = document.createElement('div');
                            userItem.className = 'user-item';
                            userItem.dataset.userId = user.user_id;

                            const statusClass = user.online_status ? 'online' : 'offline';
                            const lastSeen = user.online_status ? '' :
                                `<div class="last-seen">Last seen: ${formatLastSeen(new Date(user.last_seen))}</div>`;

                            userItem.innerHTML = `
                                <div class="user-avatar">
                                    <span>${user.username.charAt(0).toUpperCase()}</span>
                                </div>
                                <div class="user-item-info">
                                    <div class="user-item-name">${user.username}</div>
                                    ${lastSeen}
                                </div>
                                <div class="status-indicator ${statusClass}"></div>
                            `;

                            userItem.addEventListener('click', () => startConversation(user));
                            userList.appendChild(userItem);
                        });

                        usersHasMore = data.pagination.next_page > 0;
                    }

                    // Show/hide load more button
                    document.getElementById('load-more-users').style.display = usersHasMore ? 'block' : 'none';

                } catch (error) {
                    console.error('Error loading users:', error);
                    document.getElementById('user-list').innerHTML =
                        '<div class="error-state"><p>Failed to load users. Please try again.</p></div>';
                }
            }

            async function loadConversations() {
                try {
                    const response = await fetch('/conversations', {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Failed to load conversations');
                    }

                    const data = await response.json();
                    const conversationList = document.getElementById('conversation-list');

                    // Check if data exists and has the conversations property
                    if (!data || !data.conversations || data.conversations.length === 0) {
                        conversationList.innerHTML = `
                            <div class="empty-state">
                                <p>No conversations yet.</p>
                                <p>Start a chat with someone from the Users tab.</p>
                            </div>
                        `;
                        return;
                    }

                    conversationList.innerHTML = '';

                    // Append conversations to list
                    data.conversations.forEach(conv => {
                        const convItem = document.createElement('div');
                        convItem.className = 'conversation-item';
                        convItem.dataset.conversationId = conv.conversation_id;
                        convItem.dataset.userId = conv.other_user.user_id;
                        convItem.dataset.username = conv.other_user.username;

                        const statusClass = conv.other_user.online_status ? 'online' : 'offline';
                        const unreadBadge = conv.unread_count > 0 ?
                            `<div class="unread-badge">${conv.unread_count}</div>` : '';

                        convItem.innerHTML = `
                            <div class="conversation-avatar">
                                <span>${conv.other_user.username.charAt(0).toUpperCase()}</span>
                            </div>
                            <div class="conversation-info">
                                <div class="conversation-name">
                                    ${conv.other_user.username}
                                    <span class="status-dot ${statusClass}"></span>
                                </div>
                                <div class="conversation-last-message">${escapeHtml(conv.last_message.content || '')}</div>
                            </div>
                            ${unreadBadge}
                        `;

                        convItem.addEventListener('click', () => openConversation(conv));
                        conversationList.appendChild(convItem);
                    });

                } catch (error) {
                    console.error('Error loading conversations:', error);
                    document.getElementById('conversation-list').innerHTML =
                        '<div class="error-state"><p>Failed to load conversations. Please try again.</p></div>';
                }
            }

            function startConversation(user) {
                // Create a fake conversation object
                const conversation = {
                    conversation_id: getCombinedId(userId, user.user_id),
                    other_user: user,
                    last_message: { content: '' }
                };

                openConversation(conversation);

                // Switch to conversations tab
                document.querySelector('[data-tab="conversations"]').click();
            }

            function openConversation(conversation) {
                currentConversationId = conversation.conversation_id;
                currentRecipientId = conversation.other_user.user_id;
                currentRecipientUsername = conversation.other_user.username;

                // Update UI
                document.getElementById('chat-header').innerHTML = `
                    <div class="chat-header-info">
                        <h2>${conversation.other_user.username}</h2>
                        <div class="status ${conversation.other_user.online_status ? 'online' : 'offline'}">
                            ${conversation.other_user.online_status ? 'Online' : 'Offline'}
                        </div>
                    </div>
                `;

                document.getElementById('messageArea').innerHTML = '<div class="loading-messages">Loading messages...</div>';
                document.getElementById('message-input-container').style.display = 'block';

                // Load messages
                loadMessages(conversation.conversation_id);
            }

            async function loadMessages(conversationId) {
                try {
                    const response = await fetch(`/conversations/${conversationId}/messages`, {
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Failed to load messages');
                    }

                    const data = await response.json();
                    const messageArea = document.getElementById('messageArea');

                    // Initialize messages array if not present
                    const messages = data.messages || [];

                    if (messages.length === 0) {
                        messageArea.innerHTML = `
                            <div class="empty-state">
                                <p>No messages yet.</p>
                                <p>Send a message to start the conversation.</p>
                            </div>
                        `;
                    } else {
                        messageArea.innerHTML = '';

                        // Append messages to area (in reverse order since API returns newest first)
                        messages.reverse().forEach(message => {
                            appendMessage(message);
                        });

                        // Scroll to bottom
                        messageArea.scrollTop = messageArea.scrollHeight;
                    }

                } catch (error) {
                    console.error('Error loading messages:', error);
                    document.getElementById('messageArea').innerHTML =
                        '<div class="error-state"><p>Failed to load messages. Please try again.</p></div>';
                }
            }

            function appendMessage(message) {
                const messageArea = document.getElementById('messageArea');
                const isOutgoing = message.sender_id === userId;

                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isOutgoing ? 'outgoing' : 'incoming'}`;
                messageDiv.dataset.messageId = message.message_id;

                const readStatus = isOutgoing ?
                    `<div class="message-status">${message.delivery_status.read ? 'Read' : (message.delivery_status.delivered ? 'Delivered' : 'Sent')}</div>` : '';

                messageDiv.innerHTML = `
                    <div class="message-content">${escapeHtml(message.content)}</div>
                    <div class="message-meta">
                        <div class="message-time">${formatTime(new Date(message.timestamp))}</div>
                        ${readStatus}
                    </div>
                `;

                messageArea.appendChild(messageDiv);
            }

            function sendMessage() {
                const inputElement = document.getElementById('message-input');
                const content = inputElement.value.trim();

                if (!content || !currentRecipientId) return;

                // Clear input
                inputElement.value = '';

                // Generate client message ID
                const clientMessageId = generateUUID();

                // Create temporary message in UI
                const tempMessage = {
                    message_id: clientMessageId,
                    content: content,
                    sender_id: userId,
                    sender_username: username,
                    timestamp: new Date(),
                    delivery_status: { delivered: false, read: false }
                };

                appendMessage(tempMessage);

                // Scroll to bottom
                const messageArea = document.getElementById('messageArea');
                messageArea.scrollTop = messageArea.scrollHeight;

                // Send via WebSocket
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'direct_message',
                        data: {
                            recipient_id: currentRecipientId, // Make sure this is a valid user ID
                            content: content,
                            message_id: clientMessageId
                        }
                    }));

                    // Clear typing indicator
                    sendTypingIndicator('idle');
                } else {
                    // Handle offline state or socket error
                    console.error('WebSocket not connected');

                    // Show error on the message
                    const messageElement = document.querySelector(`[data-message-id="${clientMessageId}"]`);
                    if (messageElement) {
                        const statusElement = messageElement.querySelector('.message-status');
                        if (statusElement) {
                            statusElement.textContent = 'Failed to send';
                            statusElement.style.color = 'red';
                        }
                    }
                }
            }

            function sendTypingIndicator(status) {
                if (!currentRecipientId) return;

                // Clear existing timeout
                if (typingTimeout) {
                    clearTimeout(typingTimeout);
                }

                // Set new timeout to send 'idle' after 2 seconds of inactivity
                if (status === 'typing') {
                    typingTimeout = setTimeout(() => {
                        sendTypingIndicator('idle');
                    }, 2000);
                }

                // Send via WebSocket
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'typing_indicator',
                        data: {
                            recipient_id: currentRecipientId,
                            status: status
                        }
                    }));
                }
            }

            function initializeWebSocket() {
                // Close existing connection if any
                if (socket) {
                    socket.close();
                }

                // Create new connection
                socket = new WebSocket(`ws://${window.location.host}/ws?token=${accessToken}`);

                socket.onopen = function () {
                    console.log('WebSocket connection established');

                    // Send presence update to indicate online status
                    socket.send(JSON.stringify({
                        type: 'presence',
                        data: {
                            status: 'online'
                        }
                    }));
                };

                socket.onmessage = function (event) {
                    handleWebSocketMessage(JSON.parse(event.data));
                };

                socket.onclose = function () {
                    console.log('WebSocket connection closed');

                    // Try to reconnect after 5 seconds
                    setTimeout(initializeWebSocket, 5000);
                };

                socket.onerror = function (error) {
                    console.error('WebSocket error:', error);
                };
            }

            function handleWebSocketMessage(message) {
                console.log('Received WebSocket message:', message);

                switch (message.type) {
                    case 'direct_message':
                        handleDirectMessage(message.data);
                        break;
                    case 'message_ack':
                        handleMessageAcknowledgment(message.data);
                        break;
                    case 'typing_indicator':
                        handleTypingIndicator(message.data);
                        break;
                    case 'read_receipt':
                        handleReadReceipt(message.data);
                        break;
                    case 'presence_update':
                        handlePresenceUpdate(message.data);
                        break;
                    case 'error':
                        handleErrorMessage(message.data);
                        break;
                }
            }

            function handleDirectMessage(data) {
                // If we're viewing this conversation, add the message to the UI
                const conversationId = getCombinedId(userId, data.sender_id);

                // Create message object
                const message = {
                    message_id: data.message_id,
                    content: data.content,
                    sender_id: data.sender_id,
                    sender_username: data.sender_username,
                    timestamp: data.timestamp || new Date(),
                    delivery_status: { delivered: true, read: false }
                };

                // If this is for the current conversation, append it
                if (currentConversationId === conversationId) {
                    appendMessage(message);

                    // Scroll to bottom
                    const messageArea = document.getElementById('messageArea');
                    messageArea.scrollTop = messageArea.scrollHeight;

                    // Send read receipt
                    sendReadReceipt(conversationId, message.message_id);
                }

                // Update conversation list
                updateConversationWithMessage(conversationId, data.sender_id, data.sender_username, message);
            }

            function handleMessageAcknowledgment(data) {
                // Find temporary message and update status
                const messageElement = document.querySelector(`[data-message-id="${data.client_message_id}"]`);
                if (messageElement) {
                    // Update message ID to server-generated ID if available
                    if (data.server_message_id) {
                        messageElement.dataset.messageId = data.server_message_id;
                    }

                    // Update status
                    const statusElement = messageElement.querySelector('.message-status');
                    if (statusElement) {
                        statusElement.textContent = data.status === 'delivered' ? 'Delivered' : 'Sent';
                    }
                }
            }

            function handleTypingIndicator(data) {
                // Only show typing indicator for the current conversation
                if (data.user_id === currentRecipientId) {
                    const typingIndicator = document.getElementById('typing-indicator');
                    const typingUsername = document.getElementById('typing-username');

                    if (data.status === 'typing') {
                        typingUsername.textContent = data.username;
                        typingIndicator.style.display = 'block';
                        typingIndicatorVisible = true;
                    } else {
                        typingIndicator.style.display = 'none';
                        typingIndicatorVisible = false;
                    }
                }
            }

            function handleReadReceipt(data) {
                // Update messages in the current conversation
                if (currentConversationId === data.conversation_id) {
                    const messages = document.querySelectorAll('.message.outgoing');
                    messages.forEach(message => {
                        if (message.dataset.messageId <= data.last_read_message_id) {
                            const statusElement = message.querySelector('.message-status');
                            if (statusElement) {
                                statusElement.textContent = 'Read';
                            }
                        }
                    });
                }
            }

            function handlePresenceUpdate(data) {
                // Update user item in the users list
                const userItem = document.querySelector(`.user-item[data-user-id="${data.user_id}"]`);
                if (userItem) {
                    const statusIndicator = userItem.querySelector('.status-indicator');
                    if (statusIndicator) {
                        statusIndicator.className = `status-indicator ${data.status === 'online' ? 'online' : 'offline'}`;
                    }

                    // Update last seen if offline
                    if (data.status === 'offline' && data.last_seen) {
                        const lastSeenElement = userItem.querySelector('.last-seen');
                        if (lastSeenElement) {
                            lastSeenElement.textContent = `Last seen: ${formatLastSeen(new Date(data.last_seen))}`;
                        } else {
                            const userInfo = userItem.querySelector('.user-item-info');
                            const lastSeenDiv = document.createElement('div');
                            lastSeenDiv.className = 'last-seen';
                            lastSeenDiv.textContent = `Last seen: ${formatLastSeen(new Date(data.last_seen))}`;
                            userInfo.appendChild(lastSeenDiv);
                        }
                    } else if (data.status === 'online') {
                        const lastSeenElement = userItem.querySelector('.last-seen');
                        if (lastSeenElement) {
                            lastSeenElement.remove();
                        }
                    }
                }

                // Update conversation item in the conversations list
                const conversationId = getCombinedId(userId, data.user_id);
                const conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
                if (conversationItem) {
                    const statusDot = conversationItem.querySelector('.status-dot');
                    if (statusDot) {
                        statusDot.className = `status-dot ${data.status === 'online' ? 'online' : 'offline'}`;
                    }
                }

                // Update current conversation header if relevant
                if (currentRecipientId === data.user_id) {
                    const statusElement = document.querySelector('#chat-header .status');
                    if (statusElement) {
                        statusElement.className = `status ${data.status === 'online' ? 'online' : 'offline'}`;
                        statusElement.textContent = data.status === 'online' ? 'Online' : 'Offline';
                    }
                }
            }

            function handleErrorMessage(data) {
                console.error('WebSocket error:', data);

                // If related to a message, update UI
                if (data.original_message_type === 'direct_message' && data.client_message_id) {
                    const messageElement = document.querySelector(`[data-message-id="${data.client_message_id}"]`);
                    if (messageElement) {
                        const statusElement = messageElement.querySelector('.message-status');
                        if (statusElement) {
                            statusElement.textContent = 'Failed to send';
                            statusElement.style.color = 'red';
                        }
                    }
                }
            }

            function updateConversationWithMessage(conversationId, userId, username, message) {
                // Check if conversation already exists in the list
                const conversationItem = document.querySelector(`.conversation-item[data-conversation-id="${conversationId}"]`);
                const conversationList = document.getElementById('conversation-list');

                if (conversationItem) {
                    // Update existing item
                    const lastMessageElement = conversationItem.querySelector('.conversation-last-message');
                    if (lastMessageElement) {
                        lastMessageElement.textContent = message.content;
                    }

                    // Increment unread count if not current conversation
                    if (currentConversationId !== conversationId && message.sender_id !== localStorage.getItem('user_id')) {
                        let unreadBadge = conversationItem.querySelector('.unread-badge');
                        if (unreadBadge) {
                            const count = parseInt(unreadBadge.textContent) + 1;
                            unreadBadge.textContent = count;
                        } else {
                            unreadBadge = document.createElement('div');
                            unreadBadge.className = 'unread-badge';
                            unreadBadge.textContent = '1';
                            conversationItem.appendChild(unreadBadge);
                        }
                    }

                    // Move to top
                    conversationList.prepend(conversationItem);
                } else {
                    // Create new conversation item
                    const newConversationItem = document.createElement('div');
                    newConversationItem.className = 'conversation-item';
                    newConversationItem.dataset.conversationId = conversationId;
                    newConversationItem.dataset.userId = userId;
                    newConversationItem.dataset.username = username;

                    // Get online status from users list
                    const userItem = document.querySelector(`.user-item[data-user-id="${userId}"]`);
                    const isOnline = userItem ? userItem.querySelector('.status-indicator').classList.contains('online') : false;

                    // Create unread badge if needed
                    const unreadBadge = message.sender_id !== localStorage.getItem('user_id') ?
                        '<div class="unread-badge">1</div>' : '';

                    newConversationItem.innerHTML = `
                        <div class="conversation-avatar">
                            <span>${username.charAt(0).toUpperCase()}</span>
                        </div>
                        <div class="conversation-info">
                            <div class="conversation-name">
                                ${username}
                                <span class="status-dot ${isOnline ? 'online' : 'offline'}"></span>
                            </div>
                            <div class="conversation-last-message">${escapeHtml(message.content)}</div>
                        </div>
                        ${unreadBadge}
                    `;

                    // Add click event
                    newConversationItem.addEventListener('click', () => {
                        openConversation({
                            conversation_id: conversationId,
                            other_user: {
                                user_id: userId,
                                username: username,
                                online_status: isOnline
                            },
                            last_message: message
                        });
                    });

                    // Add to top of list
                    conversationList.prepend(newConversationItem);

                    // Remove empty state if it exists
                    const emptyState = conversationList.querySelector('.empty-state');
                    if (emptyState) {
                        emptyState.remove();
                    }
                }
            }

            function sendReadReceipt(conversationId, messageId) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'read_receipt',
                        data: {
                            conversation_id: conversationId,
                            last_read_message_id: messageId
                        }
                    }));
                }
            }

            async function refreshToken() {
                try {
                    const refreshToken = localStorage.getItem('refresh_token');
                    if (!refreshToken) {
                        throw new Error('No refresh token available');
                    }

                    const response = await fetch('/auth/refresh', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ refresh_token: refreshToken })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to refresh token');
                    }

                    const data = await response.json();

                    // Update tokens in localStorage
                    localStorage.setItem('access_token', data.access_token);
                    localStorage.setItem('refresh_token', data.refresh_token);
                    localStorage.setItem('expires_at', data.expires_at);

                    // Update cookie
                    document.cookie = `auth_token=${data.access_token}; path=/; max-age=900`; // 15 minutes

                } catch (error) {
                    console.error('Token refresh failed:', error);
                    // Redirect to login
                    window.location.href = '/login';
                }
            }

            async function logout() {
                try {
                    const accessToken = localStorage.getItem('access_token');

                    // Send presence update
                    // Send presence update
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({
                            type: 'presence',
                            data: {
                                status: 'offline'
                            }
                        }));
                    }

                    // Send logout request
                    await fetch('/auth/logout', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${accessToken}`
                        }
                    });

                    // Clear localStorage
                    localStorage.removeItem('access_token');
                    localStorage.removeItem('refresh_token');
                    localStorage.removeItem('user_id');
                    localStorage.removeItem('username');
                    localStorage.removeItem('expires_at');

                    // Clear cookie
                    document.cookie = 'auth_token=; path=/; max-age=0';

                    // Redirect to home
                    window.location.href = '/';

                } catch (error) {
                    console.error('Logout error:', error);
                    // Still redirect to home even if logout request fails
                    window.location.href = '/';
                }
            }

            // Helper functions
            function getCombinedId(id1, id2) {
                // Create consistent conversation ID by sorting UUIDs
                if (typeof id1 !== 'string') id1 = String(id1);
                if (typeof id2 !== 'string') id2 = String(id2);

                // Make sure both IDs are trimmed
                id1 = id1.trim();
                id2 = id2.trim();

                // Sort to ensure consistent ordering
                return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`;
            }

            function generateUUID() {
                // Simple UUID generator for client message IDs
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    var r = Math.random() * 16 | 0,
                        v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            function formatTime(date) {
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            function formatLastSeen(date) {
                const now = new Date();
                const diffMs = now - date;
                const diffMin = Math.floor(diffMs / 60000);
                const diffHrs = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMin < 1) return 'just now';
                if (diffMin < 60) return `${diffMin} minute${diffMin === 1 ? '' : 's'} ago`;
                if (diffHrs < 24) return `${diffHrs} hour${diffHrs === 1 ? '' : 's'} ago`;
                if (diffDays < 7) return `${diffDays} day${diffDays === 1 ? '' : 's'} ago`;

                return date.toLocaleDateString();
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        });
    </script>
</body>

</html>